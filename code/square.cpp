#include<vector>
#include<iostream>
#define rounds 8
#define ROOT 0x1f5U /* Generator of GF(2^8), maintains GF(2^8) */

using namespace std;

// Word lengths:
// sizeof(char) = 8 bits
// sizeof(short) = 16 bits
// sizeof(int) = 32 bits
// sizeof(long) = 64 bits

typedef unsigned char bit8;     // 8 bit word
typedef unsigned short bit16;   // 16 bit word
typedef unsigned int bit32;     // 32 bit word

// sbox for block cipher square
vector<bit16> sbox =
{0xb1, 0xce ,0xc3 ,0x95 ,0x5a ,0xad ,0xe7 ,0x02 ,0x4d ,0x44 ,0xfb ,0x91 ,0x0c ,0x87 ,0xa1 ,0x50,
 0xcb, 0x67 ,0x54 ,0xdd ,0x46 ,0x8f ,0xe1 ,0x4e ,0xf0 ,0xfd ,0xfc ,0xeb ,0xf9 ,0xc4 ,0x1a ,0x6e,
 0x5e, 0xf5 ,0xcc ,0x8d ,0x1c ,0x56 ,0x43 ,0xfe ,0x07 ,0x61 ,0xf8 ,0x75 ,0x59 ,0xff ,0x03 ,0x22,
 0x8a, 0xd1 ,0x13 ,0xee ,0x88 ,0x00 ,0x0e ,0x34 ,0x15 ,0x80 ,0x94 ,0xe3 ,0xed ,0xb5 ,0x53 ,0x23,
 0x4b, 0x47 ,0x17 ,0xa7 ,0x90 ,0x35 ,0xab ,0xd8 ,0xb8 ,0xdf ,0x4f ,0x57 ,0x9a ,0x92 ,0xdb ,0x1b,
 0x3c, 0xc8 ,0x99 ,0x04 ,0x8e ,0xe0 ,0xd7 ,0x7d ,0x85 ,0xbb ,0x40 ,0x2c ,0x3a ,0x45 ,0xf1 ,0x42,
 0x65, 0x20 ,0x41 ,0x18 ,0x72 ,0x25 ,0x93 ,0x70 ,0x36 ,0x05 ,0xf2 ,0x0b ,0xa3 ,0x79 ,0xec ,0x08,
 0x27, 0x31 ,0x32 ,0xb6 ,0x7c ,0xb0 ,0x0a ,0x73 ,0x5b ,0x7b ,0xb7 ,0x81 ,0xd2 ,0x0d ,0x6a ,0x26,
 0x9e, 0x58 ,0x9c ,0x83 ,0x74 ,0xb3 ,0xac ,0x30 ,0x7a ,0x69 ,0x77 ,0x0f ,0xae ,0x21 ,0xde ,0xd0,
 0x2e, 0x97 ,0x10 ,0xa4 ,0x98 ,0xa8 ,0xd4 ,0x68 ,0x2d ,0x62 ,0x29 ,0x6d ,0x16 ,0x49 ,0x76 ,0xc7,
 0xe8, 0xc1 ,0x96 ,0x37 ,0xe5 ,0xca ,0xf4 ,0xe9 ,0x63 ,0x12 ,0xc2 ,0xa6 ,0x14 ,0xbc ,0xd3 ,0x28,
 0xaf, 0x2f ,0xe6 ,0x24 ,0x52 ,0xc6 ,0xa0 ,0x09 ,0xbd ,0x8c ,0xcf ,0x5d ,0x11 ,0x5f ,0x01 ,0xc5,
 0x9f, 0x3d ,0xa2 ,0x9b ,0xc9 ,0x3b ,0xbe ,0x51 ,0x19 ,0x1f ,0x3f ,0x5c ,0xb2 ,0xef ,0x4a ,0xcd,
 0xbf, 0xba ,0x6f ,0x64 ,0xd9 ,0xf3 ,0x3e ,0xb4 ,0xaa ,0xdc ,0xd5 ,0x06 ,0xc0 ,0x7e ,0xf6 ,0x66,
 0x6c, 0x84 ,0x71 ,0x38 ,0xb9 ,0x1d ,0x7f ,0x9d ,0x48 ,0x8b ,0x2a ,0xda ,0xa5 ,0x33 ,0x82 ,0x39,
 0xd6, 0x78 ,0x86 ,0xfa ,0xe4 ,0x2b ,0xa9 ,0x1e ,0x89 ,0x60 ,0x6b ,0xea ,0x55 ,0x4c ,0xf7 ,0xe2};


void gamma(bit16 *matrix)
{
    // gamma function substitutes bytes using sbox
    int i;
    for(i = 0; i < 16; i++)
        matrix[i] = sbox[matrix[i]];
}


void pi(bit16 *matrix)
{
    // pi function is simple transpose
    bit16 temp;
    temp = matrix[1]; matrix[1] = matrix[4]; matrix[4] = temp;
    temp = matrix[2]; matrix[2] = matrix[8]; matrix[8] = temp;
    temp = matrix[6]; matrix[6] = matrix[9]; matrix[9] = temp;
    temp = matrix[3]; matrix[3] = matrix[0xC]; matrix[0xC] = temp;
    temp = matrix[7]; matrix[7] = matrix[0xD]; matrix[0xD] = temp;
    temp = matrix[0xB]; matrix[0xB] = matrix[0xE]; matrix[0xE] = temp;
}


void sigma(bit16 *matrix, bit16 *round_key)
{
    // sigma xors key with a matrix
    int i;
    for(i = 0; i < 16; i++)
        matrix[i] ^= round_key[i] ;
}


bit16 times2(bit16 n)
{
    // Used for multiplication with 2 in Galois Field
    n = n << 1;
    if ((n&0x100) != 0)
        n ^= ROOT;
    return n;
}


void key_schedule(bit16 *round_key, bit16 *r)
{
    // 
    bit16 temp;
    temp = round_key[0xC];
    round_key[0] ^= *r;
    round_key[0] ^= round_key[0xD]; round_key[4] ^= round_key[0]; round_key[8] ^= round_key[4]; round_key[0xC] ^= round_key[8];
    round_key[1] ^= round_key[0xE]; round_key[5] ^= round_key[1]; round_key[9] ^= round_key[5]; round_key[0xD] ^= round_key[9];
    round_key[2] ^= round_key[0xF]; round_key[6] ^= round_key[2]; round_key[0xA] ^= round_key[6]; round_key[0xE] ^= round_key[0xA];
    round_key[3] ^= temp; round_key[7] ^= round_key[3]; round_key[0xB] ^= round_key[7]; round_key[0xF] ^= round_key[0xB];
    *r = times2(*r);
}


void theta(bit16 *matrix)
{
    // This is similar to mix columns in AES just done in rows
    // A simple multiplication with a matrix C.
    // C = {{2, 3, 1, 1},
    //      {1, 2, 3, 1},
    //      {1, 1, 2, 3},
    //      {3, 1, 1, 2}};
    int i, j;
    bit16 temp[16];
    for(i = 0; i < 4; i++)
    {
        for(j = 0; j < 4; j++)
        {
            temp[4*i+j]  = times2(matrix[4*i+j]);
            temp[4*i+j] ^=        matrix[4*i+((j+1)%4)];
            temp[4*i+j] ^= times2(matrix[4*i+((j+1)%4)]);
            temp[4*i+j] ^=        matrix[4*i+((j+2)%4)];
            temp[4*i+j] ^=        matrix[4*i+((j+3)%4)];
        }
    }
    for(j = 0; j < 16; j++)
        matrix[j] = temp[j];
}


void square(bit16 *matrix, bit16 *key)
{
    bit16 r, round_key[16];
    int i;
    r = 1;
    for(i = 0; i < 16; i++)
        round_key[i] = key[i];
    theta(round_key);   /*  sigma(theta(round_key of first round)) */
    sigma(matrix,round_key);
    for(i = 0; i < 16; i++)
        round_key[i] = key[i];
    gamma(matrix); 
    pi(matrix);
    key_schedule(round_key,&r); 
    sigma(matrix,round_key);
    for(i = 2; i <= rounds; i++)
    {
        theta(matrix);
        gamma(matrix); 
        pi(matrix);
        key_schedule(round_key,&r); 
        sigma(matrix,round_key);
    }
}

int main()
{
    int count = 0;
    bit16 plaintext[] = {1, 2, 3, 4,
                5, 6, 7, 8,
                9, 10, 11, 12,
                13, 14, 15, 16};
    bit16 key[] = {1, 2, 3, 4,
                5, 6, 7, 8,
                9, 10, 11, 12,
                13, 14, 15, 16};
    square(plaintext, key);
    for(int i = 0; i < 4; i++)
    {
        for(int j = 0; j < 4; j++)
        {
            count++;
            printf("%d ", plaintext[i*4+j]);
        }
        printf("\n");
    }
    // printf("\n\n%d", count);
}